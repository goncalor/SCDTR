\subsection{Arduino Communications}
\label{sec:ArduinoCommunications}

Each luminaire has two communication components: the communications with the computer, if one is connected; the inter-luminaire communications. The first is accomplished via serial (USART converted to/from USB through the on-board ATmega16U2); while the second is implemented with I\textsuperscript{2}C/TWI.

The \texttt{loop()} in the program multiplexes the two communication channels, by checking if there is incoming data for each of them. Two functions (\texttt{wire\_process\_incoming()} and \texttt{serial\_process\_incoming()}) process data according to its origin and act on it. These functions are called only if new data is available on the respective interface. This is accomplished by checking the output of \texttt{serial\_read\_str()} for serial and a variable that is set on wire interrupts for TWI.

During the first part of the project the serial communication used a baud rate of 115200. For the second part the Arduino has many more tasks running, one of which is computing and storing the metrics. This made the communication unreliable with the baud rate previously used. Therefore the baud rate was reduced so that serial communication kept working reliably. The final baud rate is \SI{19200}{bps}. Each command that can be sent to the Arduino is made of isolated characters separated by spaces that identify the command followed by the parameters of that command. Once a command is received a custom \texttt{split()} function is applied to the incoming data buffer. This command separates the buffer on spaces and creates a list (an array) of the words that constitute the command. This list can then be used to figure which command was received and if the required arguments for that command were provided. Invalid commands can be detected and reported. If the command is correct then the corresponding actions are performed. These actions can be changes to the luminaire itself or they can involve sending commands to the other Arduinos via TWI and getting back replies.

The TWI communication is handled by using the methods from the Arduino's Wire library. These methods have some drawbacks -- for example \texttt{Wire.write()} is a blocking function -- but it sufficed to perform the needed tasks and therefore a new TWI library was not implemented (this was also a time-wise decision). Each time there is incoming TWI data an interrupt is triggered. The interrupt routine asserts via a variable that wire data was received and then copies this data to a buffer for later processing. The communication protocol implemented over TWI is similar to the one used for serial, only the commands change. The default bit rate for the Wire library was used. This bit rate is of \SI{100}{\kilo\hertz} \footnote{\href{https://github.com/arduino/Arduino/blob/435fc323e0ab3b03bc5835e5309b5022bf57388a/hardware/arduino/avr/libraries/Wire/utility/twi.h\#L28}{Arduino's GitHub, \texttt{twi.h}, line 28}}. There is some overhead for each TWI communication since a start bit, the address and mode (1 B), ACKs (1 bit for each byte of data) and a stop bit must be written to the bus, apart from the data that is actually to be sent \footnote{\href{http://i2c.info/i2c-bus-specification}{I\textsuperscript{2}C's Bus Specification}}. Therefore the nominal transmission rate is lower that the frequency the TWI is operating at. The impact of the overhead decreases with bigger packets of data. Nonetheless the Arduino's Wire library limits transmissions to payloads of 32 bytes \footnote{\href{https://github.com/arduino/Arduino/blob/435fc323e0ab3b03bc5835e5309b5022bf57388a/hardware/arduino/avr/libraries/Wire/utility/twi.h\#L28}{Arduino's GitHub, \texttt{Wire.h}, line 28}}. The bit rate could be increased up to \SI{400}{\kilo\hertz}.

